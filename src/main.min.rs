use petgraph::dot::{Config,Dot};use petgraph::graph::{Graph,NodeIndex};use linkify::{LinkFinder,LinkKind};use clap::{App,Arg};use simple_stopwatch::Stopwatch;fn main()->Result<(),reqwest::Error>{let link_graph = App::new("Link graph").version("0.0.1").author("Elliot .W <elliotwhybrow@gmail.com>").about("Makes webnet").arg(Arg::with_name("limit").short("l").long("limit").takes_value(true)).arg(Arg::with_name("v").short("v").takes_value(true)).arg(Arg::with_name("INPUT").required(true).index(1)).get_matches();let mut link_finder=LinkFinderFor::new(link_graph.value_of("limit").unwrap_or("3").parse().expect("Limit!=number"),String::from(link_graph.value_of("INPUT").unwrap()));link_finder.run();Ok(())}struct LinkFinderFor{limit:u64,link:String,pub graph:Graph<String,()>}impl LinkFinderFor{fn new(limit:u64,link:String)->Self{let mut graph=Graph::new();graph.add_node(String::from(link.clone()));Self{limit,link,graph}}fn find(&mut self,previous_node:NodeIndex,enumeration:u64){if self.limit>=enumeration{let request=reqwest::blocking::get(&self.link);match &request{Ok(_t)=>{}Err(e)=>{println!("Error: {}",e);return;}}let body=request.unwrap().text().expect("Webpage!=text");let mut finder=LinkFinder::new();finder.kinds(&[LinkKind::Url]);let links:Vec<_>=finder.links(&body).collect();for link in links{if link.as_str().contains("www")&&!link.as_str().contains("gif"){let new_node=self.graph.add_node(String::from(link.as_str()));self.graph.add_edge(previous_node,new_node,());}}for node_index in self.graph.clone().neighbors(previous_node){self.find(node_index,enumeration+1);}}}fn run(&mut self){let sw=Stopwatch::start_new();self.find(NodeIndex::new(0),1);let elapsed_ms=sw.ms();println!("{:?}",Dot::with_config(&self.graph,&[Config::EdgeNoLabel]));println!("Time taken: {}ms",elapsed_ms);}}